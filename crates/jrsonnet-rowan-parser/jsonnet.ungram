// This file describes structure of jsonnet source code
// It is also used to generate files in src/generated

// Token names ending with `!` are considered meta, and handled specifically

SourceFile = Expr

ExprBinary =
    lhs:LhsExpr
    BinaryOperator
    rhs:Expr
ExprUnary =
    UnaryOperator
    rhs:Expr
ExprSlice =
    Expr
    SliceDesc
ExprIndex =
    Expr
    '.'
    index:Name
ExprIndexExpr =
    base:LhsExpr
    '['
    index:Expr
    ']'
ExprApply =
    Expr
    ArgsDesc
    'tailstrict'?
ExprObjExtend =
    LhsExpr
    Expr
ExprParened =
    '('
    Expr
    ')'

ExprLiteral =
    Literal
ExprIntrinsicThisFile =
    '$intrinsicThisFile'
ExprIntrinsicId =
    '$intrinsicId'
ExprIntrinsic =
    '$intrinsic'
    '('
    name:Name
    ')'
ExprString =
    Text
ExprNumber =
    Number
ExprArray =
    '['
    (Expr (',' Expr)* ','?)?
    ']'
ExprObject =
    '{'
    ObjBody
    '}'
ExprArrayComp =
    '['
    Expr
    ','?
    CompSpec*
    ']'

ExprImport =
    ImportKind Text

ImportKind =
    'importstr'
|   'importbin'
|   'import'

ExprVar =
    name:Name
ExprLocal =
    'local'
    (Bind (',' Bind)* ','?)
    ';'
    Expr

ExprIfThenElse =
    'if'
    cond:Expr
    'then'
    then:TrueExpr
    ('else' else_:FalseExpr)?

ExprFunction =
    'function'
    '('
    ParamsDesc
    ')'
    Expr
ExprAssert =
    Assertion
    ';'
    Expr
ExprError =
    'error'
    Expr

Expr =
    ExprBinary
|   ExprUnary
|   ExprSlice
|   ExprIndex
|   ExprIndexExpr
|   ExprApply
|   ExprObjExtend
|   ExprParened
|   ExprIntrinsicThisFile
|   ExprIntrinsicId
|   ExprIntrinsic
|   ExprString
|   ExprNumber
|   ExprLiteral
|   ExprArray
|   ExprObject
|   ExprArrayComp
|   ExprImport
|   ExprVar
|   ExprLocal
|   ExprIfThenElse
|   ExprFunction
|   ExprAssert
|   ExprError

BinaryOperator =
    '||' | '&&'
|   '|' | '^' | '&'
|   '==' | '!=' | '<' | '>' | '<=' | '>=' | 'in'
|   '<<' | '>>'
|   '+' | '-'
|   '*' | '/' | '%'
|   'ERROR_NO_OPERATOR!'

UnaryOperator =
    '-' | '!' | '~'

SliceDescEnd=Expr
SliceDescStep=Expr
SliceDesc =
    '['
    from:Expr?
    ':'
    (
        end:SliceDescEnd?
        (
            ':'
            step:SliceDescStep?
        )?
    )?
    ']'

Name =
    'LIT_IDENT!'

ArgsDesc =
    '('
    (Arg (',' Arg)* ','?)?
    ')'
Arg =
    (name:Name '=')? Expr

ObjBodyComp =
    pre:ObjLocalPostComma*
    '['
    key:LhsExpr
    ']'
    '+'?
    ':'
    value:Expr
    post:ObjLocalPreComma*
    CompSpec*
ObjBodyMemberList =
    (Member (',' Member)* ','?)?
ObjBody =
    ObjBodyComp
|   ObjBodyMemberList

ObjLocalPostComma =
    ObjLocal
    ','
ObjLocalPreComma =
    ','
    ObjLocal

MemberBindStmt = ObjLocal
MemberAssertStmt = Assertion
MemberField = Field
Member =
    MemberBindStmt
|   MemberAssertStmt
|   MemberField

ObjLocal =
    'local'
    Bind

FieldNormal =
    FieldName
    '+'?
    Visibility
    Expr
FieldMethod =
    FieldName
    ParamsDesc
    Visibility
    Expr
Field =
    FieldNormal
|   FieldMethod

FieldNameFixed =
    id:Name
|   Text
FieldNameDynamic =
    '['
    Expr
    ']'
FieldName =
    FieldNameFixed
|   FieldNameDynamic

Visibility =
    ':::'
|   '::'
|   ':'

Literal =
    'null'
|   'true'
|   'false'
|   'self'
|   '$'
|   'super'

Text =
    'LIT_STRING_DOUBLE!'
|   'ERROR_STRING_DOUBLE_UNTERMINATED!'
|   'LIT_STRING_SINGLE!'
|   'ERROR_STRING_SINGLE_UNTERMINATED!'
|   'LIT_STRING_DOUBLE_VERBATIM!'
|   'ERROR_STRING_DOUBLE_VERBATIM_UNTERMINATED!'
|   'LIT_STRING_SINGLE_VERBATIM!'
|   'ERROR_STRING_SINGLE_VERBATIM_UNTERMINATED!'
|   'ERROR_STRING_VERBATIM_MISSING_QUOTES!'
|   'LIT_STRING_BLOCK!'
|   'ERROR_STRING_BLOCK_UNEXPECTED_END!'
|   'ERROR_STRING_BLOCK_MISSING_NEW_LINE!'
|   'ERROR_STRING_BLOCK_MISSING_TERMINATION!'
|   'ERROR_STRING_BLOCK_MISSING_INDENT!'

Number =
    'LIT_FLOAT!'
|   'ERROR_FLOAT_JUNK_AFTER_POINT!'
|   'ERROR_FLOAT_JUNK_AFTER_EXPONENT!'
|   'ERROR_FLOAT_JUNK_AFTER_EXPONENT_SIGN!'

ForSpec =
    'for'
    bind:Name
    'in'
    Expr
IfSpec =
    'if'
    Expr
CompSpec =
    ForSpec
|   IfSpec

BindDestruct =
    into:Destruct
    '='
    value:Expr
BindFunction =
    name:Name
    params:ParamsDesc
    '='
    value:Expr
Bind =
    BindDestruct
|   BindFunction

ParamsDesc =
    '('
    (Param (',' Param)* ','?)?
    ')'
Param =
    Destruct
    (
        '='
        Expr
    )?

Assertion =
    'assert'
    condition:LhsExpr
    (
        ':'
        message:Expr
    )?

DestructFull =
    Name
DestructSkip =
    '?'
DestructArray =
    '['
    (
        DestructArrayPart
        (',' DestructArrayPart)*
        ','?
    )?
    ']'
DestructObject =
    '{'
    (
        DestructObjectField
        (',' DestructObjectField)*
        ','?
    )?
    DestructRest?
    ','?
    '}'
Destruct =
    DestructFull
|   DestructSkip
|   DestructArray
|   DestructObject

DestructArrayElement =
    Destruct
DestructArrayPart =
    DestructArrayElement
|   DestructRest

DestructRest =
    '...'
    into:Name?

DestructObjectField =
    field:Name
    (
        ':'
        Destruct
    )?
    (
        '='
        Expr
    )?

// Aliases used to resolve node type conflicts
TrueExpr=Expr
FalseExpr=Expr
LhsExpr=Expr

// Trivia - tokens which will be implicitly skipped for parser
Trivia =
    'LIT_WHITESPACE!'
|   'LIT_MULTI_LINE_COMMENT!'
|   'ERROR_COMMENT_TOO_SHORT!'
|   'ERROR_COMMENT_UNTERMINATED!'
|   'LIT_SINGLE_LINE_HASH_COMMENT!'
|   'LIT_SINGLE_LINE_SLASH_COMMENT!'
